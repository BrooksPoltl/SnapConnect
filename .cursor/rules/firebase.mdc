---
description: Firebase best practices
globs: 
alwaysApply: false
---
These rules ensure efficient, secure, and maintainable Firebase (Firestore) integration in React Native projects using Expo. They apply to Firestore logic in `services/` or files with Firestore operations. They build on the [General Rules](./general.cursorrules), [TypeScript Rules](./typescript.cursorrules), [Component Rules](./components.cursorrules), and [Styling Rules](./styles.cursorrules).

## General Guidelines
- Use the `@react-native-firebase/firestore` package for native performance with Expo.
- Place all Firestore logic in `services/` directory, such as a `firestore.ts` file, for modularity.
- Avoid direct Firestore calls in components; encapsulate logic in services or hooks (see Hooks Rules).
- Use TypeScript interfaces for Firestore documents, as outlined in TypeScript Rules.

## Data Fetching
- Implement cursor-based pagination using `limit`, `startAfter`, and `orderBy` for efficient data retrieval.
- Prefer one-time queries with `get()` over real-time listeners with `onSnapshot` unless real-time updates are required.
- Use batch writes for multiple Firestore operations to minimize network calls.
- Example: A function to fetch users should paginate by ordering on a field like `name`, limiting results, and using a last document snapshot for continuation.

## Security
- Secure Firestore with Firebase Security Rules to restrict unauthorized access.
- Validate data in Security Rules to enforce schema-like constraints, such as ensuring fields are of correct types.
- Example: Rules for a `users` collection should allow read/write only for authenticated users matching the document's user ID.

## Type Safety
- Use `FirebaseFirestoreTypes` from `@react-native-firebase/firestore` for type-safe Firestore queries.
- Define interfaces for Firestore documents in a `types/` directory, such as a `user.ts` file.
- Example: An interface for a `Post` document should include fields like `id`, `title`, and a timestamp type from Firestore.

## Error Handling
- Wrap all Firestore operations in `try-catch` blocks and throw typed errors.
- Log errors to Firebase Crashlytics or Sentry using `expo-error-reporter` for monitoring.
- Display user-friendly error messages in the UI, as per Component Rules.
- Example: A function to delete a user should catch errors, throw a custom error with a message and optional code, and log the issue.

## Performance
- Minimize Firestore reads and writes by using `limit` and creating indexes for complex queries.
- Cache frequently accessed data with `react-query` when suitable.
- Use `getCountFromServer` to retrieve collection counts instead of fetching all documents.
- Example: A function to count users should use `getCountFromServer` to return the total number of documents efficiently.

## Configuration
- Store Firebase configuration in environment variables using `expo-constants`.
- Initialize Firebase in a single file, such as `firebase.ts`, or in `App.tsx`.
- Example: Initialize Firebase with config from environment variables, checking if the app is already initialized to avoid duplicates.

## Notes
- Define Firestore indexes in a `firestore.indexes.json` file for complex queries to improve performance.
- Monitor Firestore usage in the Firebase Console to optimize costs and identify inefficiencies.
- Prefer flat data structures over nested ones to enhance scalability.
- Refer to Firebase documentation for detailed Firestore usage guidelines.
